entry event packetin (int timestamp, int srcip);
event collect (int key);
event transform_and_combine (int key);
event report_new_val (int key);
event main (int key, int new_val);

const int TRUE = 1;
const int FALSE = 0;
const int HASH_SEED = 10398247;
const int TABLE_SIZE = 1024;
global Array.t<<32>> keys = Array.create(TABLE_SIZE);
global Array.t<<32>> values = Array.create(TABLE_SIZE);

// compiled from collect combine function
memop combine(int memval, int incrval) {
    return memval + incrval;
}

// second step of collect: perform transform/combine operations
handle transform_and_combine (int key) {
    // compiled from collect k/v transform function
    int transformed = 1;

    int<<10>> idx = hash<<10>>(HASH_SEED, key, TABLE_SIZE);
    Array.setm(values, idx, combine, transformed);
    generate report_new_val (key);
}

// collect "exit" event: report new value of "table row" to next
// table operation (in this case, there is none)
handle report_new_val (int key) {
    int<<10>> idx = hash<<10>>(HASH_SEED, key, TABLE_SIZE);
    int new_val = Array.get(values, idx);
    generate main (key, new_val);
}

// first step of collect: drop keys that there is no
// space for
handle collect (int key) {
    int<<10>> idx = hash<<10>>(HASH_SEED, key, TABLE_SIZE);

    int stored_key = Array.get(keys, idx);
 
    // keep packet if index hasn't been written to or if it has,
    // if the stored key is the same as the packet's key
    if (stored_key == 0 || stored_key == key) {
        generate transform_and_combine (key);
    }
}

// entry event (compiled from thePackets)
handle packetin (int timestamp, int srcip) {
    // compiled filter operation
    if (srcip != 167772161) {
        // compiled collect operation
        generate collect (srcip);
    }
}

// Everything above (data aggregation) compiled

// Below code (control logic) written by user

exit event block_packet (int srcip);

// define "exit" event, event definition autogenerated but
// expected to be handled by user
handle main (int key, int new_val) {
  int srcip = key;
  int count = new_val;
  if (count > 2) {
    generate block_packet(srcip);
  }
}
